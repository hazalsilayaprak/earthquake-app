{"ast":null,"code":"/**\n * @module ol/source/VectorTile\n */\nimport EventType from '../events/EventType.js';\nimport Tile from '../VectorTile.js';\nimport TileCache from '../TileCache.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport TileState from '../TileState.js';\nimport UrlTile from './UrlTile.js';\nimport VectorRenderTile from '../VectorRenderTile.js';\nimport { DEFAULT_MAX_ZOOM } from '../tilegrid/common.js';\nimport { buffer as bufferExtent, getIntersection, intersects } from '../extent.js';\nimport { createXYZ, extentFromProjection } from '../tilegrid.js';\nimport { fromKey, getCacheKeyForTileKey, getKeyZXY } from '../tilecoord.js';\nimport { isEmpty } from '../obj.js';\nimport { loadFeaturesXhr } from '../featureloader.js';\nimport { toSize } from '../size.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.\n * @property {import(\"../extent.js\").Extent} [extent] Extent.\n * @property {import(\"../format/Feature.js\").default} [format] Feature format for tiles. Used and required by the default.\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\n * to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.\n * @property {import(\"./Source.js\").State} [state] Source state.\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/VectorTile~VectorTile}.\n * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\n * Optional function to load a tile given a URL. Could look like this for pbf tiles:\n * ```js\n * function(tile, url) {\n *   tile.setLoader(function(extent, resolution, projection) {\n *     fetch(url).then(function(response) {\n *       response.arrayBuffer().then(function(data) {\n *         const format = tile.getFormat() // ol/format/MVT configured as source format\n *         const features = format.readFeatures(data, {\n *           extent: extent,\n *           featureProjection: projection\n *         });\n *         tile.setFeatures(features);\n *       });\n *     });\n *   });\n * }\n * ```\n * If you do not need extent, resolution and projection to get the features for a tile (e.g.\n * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure\n * to call `setFeatures()` on the tile:\n * ```js\n * const format = new GeoJSON({featureProjection: map.getView().getProjection()});\n * async function tileLoadFunction(tile, url) {\n *   const response = await fetch(url);\n *   const data = await response.json();\n *   tile.setFeatures(format.readFeatures(data));\n * }\n * ```\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {number} [transition] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\n * render multiple worlds.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=1]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Class for layer sources providing vector data divided into a tile grid, to be\n * used with {@link module:ol/layer/VectorTile~VectorTileLayer}. Although this source receives tiles\n * with vector features from the server, it is not meant for feature editing.\n * Features are optimized for rendering, their geometries are clipped at or near\n * tile boundaries and simplified for a view resolution. See\n * {@link module:ol/source/Vector~VectorSource} for vector sources that are suitable for feature\n * editing.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\n\nclass VectorTile extends UrlTile {\n  /**\n   * @param {!Options} options Vector tile options.\n   */\n  constructor(options) {\n    const projection = options.projection || 'EPSG:3857';\n    const extent = options.extent || extentFromProjection(projection);\n    const tileGrid = options.tileGrid || createXYZ({\n      extent: extent,\n      maxResolution: options.maxResolution,\n      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,\n      minZoom: options.minZoom,\n      tileSize: options.tileSize || 512\n    });\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      interpolate: true,\n      opaque: false,\n      projection: projection,\n      state: options.state,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultLoadFunction,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX === undefined ? true : options.wrapX,\n      transition: options.transition,\n      zDirection: options.zDirection === undefined ? 1 : options.zDirection\n    });\n    /**\n     * @private\n     * @type {import(\"../format/Feature.js\").default|null}\n     */\n\n    this.format_ = options.format ? options.format : null;\n    /**\n     * @private\n     * @type {TileCache}\n     */\n\n    this.sourceTileCache = new TileCache(this.tileCache.highWaterMark);\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n    /**\n     * @protected\n     * @type {typeof import(\"../VectorTile.js\").default}\n     */\n\n    this.tileClass = options.tileClass ? options.tileClass : Tile;\n    /**\n     * @private\n     * @type {Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n\n    this.tileGrids_ = {};\n  }\n  /**\n   * Get features whose bounding box intersects the provided extent. Only features for cached\n   * tiles for the last rendered zoom level are available in the source. So this method is only\n   * suitable for requesting tiles for extents that are currently rendered.\n   *\n   * Features are returned in random tile order and as they are included in the tiles. This means\n   * they can be clipped, duplicated across tiles, and simplified to the render resolution.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n   * @api\n   */\n\n\n  getFeaturesInExtent(extent) {\n    const features = [];\n    const tileCache = this.tileCache;\n\n    if (tileCache.getCount() === 0) {\n      return features;\n    }\n\n    const z = fromKey(tileCache.peekFirstKey())[0];\n    const tileGrid = this.tileGrid;\n    tileCache.forEach(function (tile) {\n      if (tile.tileCoord[0] !== z || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n\n      const sourceTiles = tile.getSourceTiles();\n\n      for (let i = 0, ii = sourceTiles.length; i < ii; ++i) {\n        const sourceTile = sourceTiles[i];\n        const tileCoord = sourceTile.tileCoord;\n\n        if (intersects(extent, tileGrid.getTileCoordExtent(tileCoord))) {\n          const tileFeatures = sourceTile.getFeatures();\n\n          if (tileFeatures) {\n            for (let j = 0, jj = tileFeatures.length; j < jj; ++j) {\n              const candidate = tileFeatures[j];\n              const geometry = candidate.getGeometry();\n\n              if (intersects(extent, geometry.getExtent())) {\n                features.push(candidate);\n              }\n            }\n          }\n        }\n      }\n    });\n    return features;\n  }\n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n\n\n  getOverlaps() {\n    return this.overlaps_;\n  }\n  /**\n   * clear {@link module:ol/TileCache~TileCache} and delete all source tiles\n   * @api\n   */\n\n\n  clear() {\n    this.tileCache.clear();\n    this.sourceTileCache.clear();\n  }\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n\n\n  expireCache(projection, usedTiles) {\n    const tileCache = this.getTileCacheForProjection(projection);\n    const usedSourceTiles = Object.keys(usedTiles).reduce((acc, key) => {\n      const cacheKey = getCacheKeyForTileKey(key);\n      const tile = tileCache.peek(cacheKey);\n\n      if (tile) {\n        const sourceTiles = tile.sourceTiles;\n\n        for (let i = 0, ii = sourceTiles.length; i < ii; ++i) {\n          acc[sourceTiles[i].getKey()] = true;\n        }\n      }\n\n      return acc;\n    }, {});\n    super.expireCache(projection, usedTiles);\n    this.sourceTileCache.expireCache(usedSourceTiles);\n  }\n  /**\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection\").default} projection Projection.\n   * @param {VectorRenderTile} tile Vector image tile.\n   * @return {Array<import(\"../VectorTile\").default>} Tile keys.\n   */\n\n\n  getSourceTiles(pixelRatio, projection, tile) {\n    if (tile.getState() === TileState.IDLE) {\n      tile.setState(TileState.LOADING);\n      const urlTileCoord = tile.wrappedTileCoord;\n      const tileGrid = this.getTileGridForProjection(projection);\n      const extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      const z = urlTileCoord[0];\n      const resolution = tileGrid.getResolution(z); // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n\n      bufferExtent(extent, -resolution, extent);\n      const sourceTileGrid = this.tileGrid;\n      const sourceExtent = sourceTileGrid.getExtent();\n\n      if (sourceExtent) {\n        getIntersection(extent, sourceExtent, extent);\n      }\n\n      const sourceZ = sourceTileGrid.getZForResolution(resolution, this.zDirection);\n      sourceTileGrid.forEachTileCoord(extent, sourceZ, sourceTileCoord => {\n        const tileUrl = this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n        const sourceTile = this.sourceTileCache.containsKey(tileUrl) ? this.sourceTileCache.get(tileUrl) : new this.tileClass(sourceTileCoord, tileUrl ? TileState.IDLE : TileState.EMPTY, tileUrl, this.format_, this.tileLoadFunction);\n        tile.sourceTiles.push(sourceTile);\n        const sourceTileState = sourceTile.getState();\n\n        if (sourceTileState < TileState.LOADED) {\n          const listenChange = event => {\n            this.handleTileChange(event);\n            const state = sourceTile.getState();\n\n            if (state === TileState.LOADED || state === TileState.ERROR) {\n              const sourceTileKey = sourceTile.getKey();\n\n              if (sourceTileKey in tile.errorTileKeys) {\n                if (sourceTile.getState() === TileState.LOADED) {\n                  delete tile.errorTileKeys[sourceTileKey];\n                }\n              } else {\n                tile.loadingSourceTiles--;\n              }\n\n              if (state === TileState.ERROR) {\n                tile.errorTileKeys[sourceTileKey] = true;\n              } else {\n                sourceTile.removeEventListener(EventType.CHANGE, listenChange);\n              }\n\n              if (tile.loadingSourceTiles === 0) {\n                tile.setState(isEmpty(tile.errorTileKeys) ? TileState.LOADED : TileState.ERROR);\n              }\n            }\n          };\n\n          sourceTile.addEventListener(EventType.CHANGE, listenChange);\n          tile.loadingSourceTiles++;\n        }\n\n        if (sourceTileState === TileState.IDLE) {\n          sourceTile.extent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n          sourceTile.projection = projection;\n          sourceTile.resolution = sourceTileGrid.getResolution(sourceTileCoord[0]);\n          this.sourceTileCache.set(tileUrl, sourceTile);\n          sourceTile.load();\n        }\n      });\n\n      if (!tile.loadingSourceTiles) {\n        tile.setState(tile.sourceTiles.some(sourceTile => sourceTile.getState() === TileState.ERROR) ? TileState.ERROR : TileState.LOADED);\n      }\n    }\n\n    return tile.sourceTiles;\n  }\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!VectorRenderTile} Tile.\n   */\n\n\n  getTile(z, x, y, pixelRatio, projection) {\n    const coordKey = getKeyZXY(z, x, y);\n    const key = this.getKey();\n    let tile;\n\n    if (this.tileCache.containsKey(coordKey)) {\n      tile = this.tileCache.get(coordKey);\n\n      if (tile.key === key) {\n        return tile;\n      }\n    }\n\n    const tileCoord = [z, x, y];\n    let urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n    const sourceExtent = this.getTileGrid().getExtent();\n    const tileGrid = this.getTileGridForProjection(projection);\n\n    if (urlTileCoord && sourceExtent) {\n      const tileExtent = tileGrid.getTileCoordExtent(urlTileCoord); // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n\n      bufferExtent(tileExtent, -tileGrid.getResolution(z), tileExtent);\n\n      if (!intersects(sourceExtent, tileExtent)) {\n        urlTileCoord = null;\n      }\n    }\n\n    let empty = true;\n\n    if (urlTileCoord !== null) {\n      const sourceTileGrid = this.tileGrid;\n      const resolution = tileGrid.getResolution(z);\n      const sourceZ = sourceTileGrid.getZForResolution(resolution, 1); // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n\n      const extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      bufferExtent(extent, -resolution, extent);\n      sourceTileGrid.forEachTileCoord(extent, sourceZ, function (sourceTileCoord) {\n        empty = empty && !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n      }.bind(this));\n    }\n\n    const newTile = new VectorRenderTile(tileCoord, empty ? TileState.EMPTY : TileState.IDLE, urlTileCoord, this.getSourceTiles.bind(this, pixelRatio, projection));\n    newTile.key = key;\n\n    if (tile) {\n      newTile.interimTile = tile;\n      newTile.refreshInterimChain();\n      this.tileCache.replace(coordKey, newTile);\n    } else {\n      this.tileCache.set(coordKey, newTile);\n    }\n\n    return newTile;\n  }\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n\n\n  getTileGridForProjection(projection) {\n    const code = projection.getCode();\n    let tileGrid = this.tileGrids_[code];\n\n    if (!tileGrid) {\n      // A tile grid that matches the tile size of the source tile grid is more\n      // likely to have 1:1 relationships between source tiles and rendered tiles.\n      const sourceTileGrid = this.tileGrid;\n      const resolutions = sourceTileGrid.getResolutions().slice();\n      const origins = resolutions.map(function (resolution, z) {\n        return sourceTileGrid.getOrigin(z);\n      });\n      const tileSizes = resolutions.map(function (resolution, z) {\n        return sourceTileGrid.getTileSize(z);\n      });\n      const length = DEFAULT_MAX_ZOOM + 1;\n\n      for (let z = resolutions.length; z < length; ++z) {\n        resolutions.push(resolutions[z - 1] / 2);\n        origins.push(origins[z - 1]);\n        tileSizes.push(tileSizes[z - 1]);\n      }\n\n      tileGrid = new TileGrid({\n        extent: sourceTileGrid.getExtent(),\n        origins: origins,\n        resolutions: resolutions,\n        tileSizes: tileSizes\n      });\n      this.tileGrids_[code] = tileGrid;\n    }\n\n    return tileGrid;\n  }\n  /**\n   * Get the tile pixel ratio for this source.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n\n\n  getTilePixelRatio(pixelRatio) {\n    return pixelRatio;\n  }\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   */\n\n\n  getTilePixelSize(z, pixelRatio, projection) {\n    const tileGrid = this.getTileGridForProjection(projection);\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    return [Math.round(tileSize[0] * pixelRatio), Math.round(tileSize[1] * pixelRatio)];\n  }\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n\n\n  updateCacheSize(tileCount, projection) {\n    super.updateCacheSize(tileCount * 2, projection);\n    this.sourceTileCache.highWaterMark = this.getTileCacheForProjection(projection).highWaterMark;\n  }\n\n}\n\nexport default VectorTile;\n/**\n * Sets the loader for a tile.\n * @param {import(\"../VectorTile.js\").default} tile Vector tile.\n * @param {string} url URL.\n */\n\nexport function defaultLoadFunction(tile, url) {\n  tile.setLoader(\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  function (extent, resolution, projection) {\n    loadFeaturesXhr(url, tile.getFormat(), extent, resolution, projection, tile.onLoad.bind(tile), tile.onError.bind(tile));\n  });\n}","map":{"version":3,"sources":["/Users/hazalsilayaprak/Projects/earthquake-app/node_modules/ol/source/VectorTile.js"],"names":["EventType","Tile","TileCache","TileGrid","TileState","UrlTile","VectorRenderTile","DEFAULT_MAX_ZOOM","buffer","bufferExtent","getIntersection","intersects","createXYZ","extentFromProjection","fromKey","getCacheKeyForTileKey","getKeyZXY","isEmpty","loadFeaturesXhr","toSize","VectorTile","constructor","options","projection","extent","tileGrid","maxResolution","maxZoom","undefined","minZoom","tileSize","attributions","attributionsCollapsible","cacheSize","interpolate","opaque","state","tileLoadFunction","defaultLoadFunction","tileUrlFunction","url","urls","wrapX","transition","zDirection","format_","format","sourceTileCache","tileCache","highWaterMark","overlaps_","overlaps","tileClass","tileGrids_","getFeaturesInExtent","features","getCount","z","peekFirstKey","forEach","tile","tileCoord","getState","LOADED","sourceTiles","getSourceTiles","i","ii","length","sourceTile","getTileCoordExtent","tileFeatures","getFeatures","j","jj","candidate","geometry","getGeometry","getExtent","push","getOverlaps","clear","expireCache","usedTiles","getTileCacheForProjection","usedSourceTiles","Object","keys","reduce","acc","key","cacheKey","peek","getKey","pixelRatio","IDLE","setState","LOADING","urlTileCoord","wrappedTileCoord","getTileGridForProjection","resolution","getResolution","sourceTileGrid","sourceExtent","sourceZ","getZForResolution","forEachTileCoord","sourceTileCoord","tileUrl","containsKey","get","EMPTY","sourceTileState","listenChange","event","handleTileChange","ERROR","sourceTileKey","errorTileKeys","loadingSourceTiles","removeEventListener","CHANGE","addEventListener","set","load","some","getTile","x","y","coordKey","getTileCoordForTileUrlFunction","getTileGrid","tileExtent","empty","bind","newTile","interimTile","refreshInterimChain","replace","code","getCode","resolutions","getResolutions","slice","origins","map","getOrigin","tileSizes","getTileSize","getTilePixelRatio","getTilePixelSize","tmpSize","Math","round","updateCacheSize","tileCount","setLoader","getFormat","onLoad","onError"],"mappings":"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","sourcesContent":["/**\n * @module ol/source/VectorTile\n */\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../VectorTile.js';\nimport TileCache from '../TileCache.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport TileState from '../TileState.js';\nimport UrlTile from './UrlTile.js';\nimport VectorRenderTile from '../VectorRenderTile.js';\nimport {DEFAULT_MAX_ZOOM} from '../tilegrid/common.js';\nimport {\n  buffer as bufferExtent,\n  getIntersection,\n  intersects,\n} from '../extent.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\nimport {fromKey, getCacheKeyForTileKey, getKeyZXY} from '../tilecoord.js';\nimport {isEmpty} from '../obj.js';\nimport {loadFeaturesXhr} from '../featureloader.js';\nimport {toSize} from '../size.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.\n * @property {import(\"../extent.js\").Extent} [extent] Extent.\n * @property {import(\"../format/Feature.js\").default} [format] Feature format for tiles. Used and required by the default.\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\n * to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.\n * @property {import(\"./Source.js\").State} [state] Source state.\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/VectorTile~VectorTile}.\n * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\n * Optional function to load a tile given a URL. Could look like this for pbf tiles:\n * ```js\n * function(tile, url) {\n *   tile.setLoader(function(extent, resolution, projection) {\n *     fetch(url).then(function(response) {\n *       response.arrayBuffer().then(function(data) {\n *         const format = tile.getFormat() // ol/format/MVT configured as source format\n *         const features = format.readFeatures(data, {\n *           extent: extent,\n *           featureProjection: projection\n *         });\n *         tile.setFeatures(features);\n *       });\n *     });\n *   });\n * }\n * ```\n * If you do not need extent, resolution and projection to get the features for a tile (e.g.\n * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure\n * to call `setFeatures()` on the tile:\n * ```js\n * const format = new GeoJSON({featureProjection: map.getView().getProjection()});\n * async function tileLoadFunction(tile, url) {\n *   const response = await fetch(url);\n *   const data = await response.json();\n *   tile.setFeatures(format.readFeatures(data));\n * }\n * ```\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {number} [transition] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\n * render multiple worlds.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=1]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Class for layer sources providing vector data divided into a tile grid, to be\n * used with {@link module:ol/layer/VectorTile~VectorTileLayer}. Although this source receives tiles\n * with vector features from the server, it is not meant for feature editing.\n * Features are optimized for rendering, their geometries are clipped at or near\n * tile boundaries and simplified for a view resolution. See\n * {@link module:ol/source/Vector~VectorSource} for vector sources that are suitable for feature\n * editing.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nclass VectorTile extends UrlTile {\n  /**\n   * @param {!Options} options Vector tile options.\n   */\n  constructor(options) {\n    const projection = options.projection || 'EPSG:3857';\n\n    const extent = options.extent || extentFromProjection(projection);\n\n    const tileGrid =\n      options.tileGrid ||\n      createXYZ({\n        extent: extent,\n        maxResolution: options.maxResolution,\n        maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,\n        minZoom: options.minZoom,\n        tileSize: options.tileSize || 512,\n      });\n\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      interpolate: true,\n      opaque: false,\n      projection: projection,\n      state: options.state,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction\n        ? options.tileLoadFunction\n        : defaultLoadFunction,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX === undefined ? true : options.wrapX,\n      transition: options.transition,\n      zDirection: options.zDirection === undefined ? 1 : options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {import(\"../format/Feature.js\").default|null}\n     */\n    this.format_ = options.format ? options.format : null;\n\n    /**\n     * @private\n     * @type {TileCache}\n     */\n    this.sourceTileCache = new TileCache(this.tileCache.highWaterMark);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n\n    /**\n     * @protected\n     * @type {typeof import(\"../VectorTile.js\").default}\n     */\n    this.tileClass = options.tileClass ? options.tileClass : Tile;\n\n    /**\n     * @private\n     * @type {Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    this.tileGrids_ = {};\n  }\n\n  /**\n   * Get features whose bounding box intersects the provided extent. Only features for cached\n   * tiles for the last rendered zoom level are available in the source. So this method is only\n   * suitable for requesting tiles for extents that are currently rendered.\n   *\n   * Features are returned in random tile order and as they are included in the tiles. This means\n   * they can be clipped, duplicated across tiles, and simplified to the render resolution.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n   * @api\n   */\n  getFeaturesInExtent(extent) {\n    const features = [];\n    const tileCache = this.tileCache;\n    if (tileCache.getCount() === 0) {\n      return features;\n    }\n    const z = fromKey(tileCache.peekFirstKey())[0];\n    const tileGrid = this.tileGrid;\n    tileCache.forEach(function (tile) {\n      if (tile.tileCoord[0] !== z || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      const sourceTiles = tile.getSourceTiles();\n      for (let i = 0, ii = sourceTiles.length; i < ii; ++i) {\n        const sourceTile = sourceTiles[i];\n        const tileCoord = sourceTile.tileCoord;\n        if (intersects(extent, tileGrid.getTileCoordExtent(tileCoord))) {\n          const tileFeatures = sourceTile.getFeatures();\n          if (tileFeatures) {\n            for (let j = 0, jj = tileFeatures.length; j < jj; ++j) {\n              const candidate = tileFeatures[j];\n              const geometry = candidate.getGeometry();\n              if (intersects(extent, geometry.getExtent())) {\n                features.push(candidate);\n              }\n            }\n          }\n        }\n      }\n    });\n    return features;\n  }\n\n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n  getOverlaps() {\n    return this.overlaps_;\n  }\n\n  /**\n   * clear {@link module:ol/TileCache~TileCache} and delete all source tiles\n   * @api\n   */\n  clear() {\n    this.tileCache.clear();\n    this.sourceTileCache.clear();\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  expireCache(projection, usedTiles) {\n    const tileCache = this.getTileCacheForProjection(projection);\n    const usedSourceTiles = Object.keys(usedTiles).reduce((acc, key) => {\n      const cacheKey = getCacheKeyForTileKey(key);\n      const tile = tileCache.peek(cacheKey);\n      if (tile) {\n        const sourceTiles = tile.sourceTiles;\n        for (let i = 0, ii = sourceTiles.length; i < ii; ++i) {\n          acc[sourceTiles[i].getKey()] = true;\n        }\n      }\n      return acc;\n    }, {});\n    super.expireCache(projection, usedTiles);\n    this.sourceTileCache.expireCache(usedSourceTiles);\n  }\n\n  /**\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection\").default} projection Projection.\n   * @param {VectorRenderTile} tile Vector image tile.\n   * @return {Array<import(\"../VectorTile\").default>} Tile keys.\n   */\n  getSourceTiles(pixelRatio, projection, tile) {\n    if (tile.getState() === TileState.IDLE) {\n      tile.setState(TileState.LOADING);\n      const urlTileCoord = tile.wrappedTileCoord;\n      const tileGrid = this.getTileGridForProjection(projection);\n      const extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      const z = urlTileCoord[0];\n      const resolution = tileGrid.getResolution(z);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      bufferExtent(extent, -resolution, extent);\n      const sourceTileGrid = this.tileGrid;\n      const sourceExtent = sourceTileGrid.getExtent();\n      if (sourceExtent) {\n        getIntersection(extent, sourceExtent, extent);\n      }\n      const sourceZ = sourceTileGrid.getZForResolution(\n        resolution,\n        this.zDirection\n      );\n\n      sourceTileGrid.forEachTileCoord(extent, sourceZ, (sourceTileCoord) => {\n        const tileUrl = this.tileUrlFunction(\n          sourceTileCoord,\n          pixelRatio,\n          projection\n        );\n        const sourceTile = this.sourceTileCache.containsKey(tileUrl)\n          ? this.sourceTileCache.get(tileUrl)\n          : new this.tileClass(\n              sourceTileCoord,\n              tileUrl ? TileState.IDLE : TileState.EMPTY,\n              tileUrl,\n              this.format_,\n              this.tileLoadFunction\n            );\n        tile.sourceTiles.push(sourceTile);\n        const sourceTileState = sourceTile.getState();\n        if (sourceTileState < TileState.LOADED) {\n          const listenChange = (event) => {\n            this.handleTileChange(event);\n            const state = sourceTile.getState();\n            if (state === TileState.LOADED || state === TileState.ERROR) {\n              const sourceTileKey = sourceTile.getKey();\n              if (sourceTileKey in tile.errorTileKeys) {\n                if (sourceTile.getState() === TileState.LOADED) {\n                  delete tile.errorTileKeys[sourceTileKey];\n                }\n              } else {\n                tile.loadingSourceTiles--;\n              }\n              if (state === TileState.ERROR) {\n                tile.errorTileKeys[sourceTileKey] = true;\n              } else {\n                sourceTile.removeEventListener(EventType.CHANGE, listenChange);\n              }\n              if (tile.loadingSourceTiles === 0) {\n                tile.setState(\n                  isEmpty(tile.errorTileKeys)\n                    ? TileState.LOADED\n                    : TileState.ERROR\n                );\n              }\n            }\n          };\n          sourceTile.addEventListener(EventType.CHANGE, listenChange);\n          tile.loadingSourceTiles++;\n        }\n        if (sourceTileState === TileState.IDLE) {\n          sourceTile.extent =\n            sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n          sourceTile.projection = projection;\n          sourceTile.resolution = sourceTileGrid.getResolution(\n            sourceTileCoord[0]\n          );\n          this.sourceTileCache.set(tileUrl, sourceTile);\n          sourceTile.load();\n        }\n      });\n      if (!tile.loadingSourceTiles) {\n        tile.setState(\n          tile.sourceTiles.some(\n            (sourceTile) => sourceTile.getState() === TileState.ERROR\n          )\n            ? TileState.ERROR\n            : TileState.LOADED\n        );\n      }\n    }\n\n    return tile.sourceTiles;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!VectorRenderTile} Tile.\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const coordKey = getKeyZXY(z, x, y);\n    const key = this.getKey();\n    let tile;\n    if (this.tileCache.containsKey(coordKey)) {\n      tile = this.tileCache.get(coordKey);\n      if (tile.key === key) {\n        return tile;\n      }\n    }\n    const tileCoord = [z, x, y];\n    let urlTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      projection\n    );\n    const sourceExtent = this.getTileGrid().getExtent();\n    const tileGrid = this.getTileGridForProjection(projection);\n    if (urlTileCoord && sourceExtent) {\n      const tileExtent = tileGrid.getTileCoordExtent(urlTileCoord);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      bufferExtent(tileExtent, -tileGrid.getResolution(z), tileExtent);\n      if (!intersects(sourceExtent, tileExtent)) {\n        urlTileCoord = null;\n      }\n    }\n    let empty = true;\n    if (urlTileCoord !== null) {\n      const sourceTileGrid = this.tileGrid;\n      const resolution = tileGrid.getResolution(z);\n      const sourceZ = sourceTileGrid.getZForResolution(resolution, 1);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      const extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      bufferExtent(extent, -resolution, extent);\n      sourceTileGrid.forEachTileCoord(\n        extent,\n        sourceZ,\n        function (sourceTileCoord) {\n          empty =\n            empty &&\n            !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n        }.bind(this)\n      );\n    }\n    const newTile = new VectorRenderTile(\n      tileCoord,\n      empty ? TileState.EMPTY : TileState.IDLE,\n      urlTileCoord,\n      this.getSourceTiles.bind(this, pixelRatio, projection)\n    );\n\n    newTile.key = key;\n    if (tile) {\n      newTile.interimTile = tile;\n      newTile.refreshInterimChain();\n      this.tileCache.replace(coordKey, newTile);\n    } else {\n      this.tileCache.set(coordKey, newTile);\n    }\n    return newTile;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n  getTileGridForProjection(projection) {\n    const code = projection.getCode();\n    let tileGrid = this.tileGrids_[code];\n    if (!tileGrid) {\n      // A tile grid that matches the tile size of the source tile grid is more\n      // likely to have 1:1 relationships between source tiles and rendered tiles.\n      const sourceTileGrid = this.tileGrid;\n      const resolutions = sourceTileGrid.getResolutions().slice();\n      const origins = resolutions.map(function (resolution, z) {\n        return sourceTileGrid.getOrigin(z);\n      });\n      const tileSizes = resolutions.map(function (resolution, z) {\n        return sourceTileGrid.getTileSize(z);\n      });\n      const length = DEFAULT_MAX_ZOOM + 1;\n      for (let z = resolutions.length; z < length; ++z) {\n        resolutions.push(resolutions[z - 1] / 2);\n        origins.push(origins[z - 1]);\n        tileSizes.push(tileSizes[z - 1]);\n      }\n      tileGrid = new TileGrid({\n        extent: sourceTileGrid.getExtent(),\n        origins: origins,\n        resolutions: resolutions,\n        tileSizes: tileSizes,\n      });\n      this.tileGrids_[code] = tileGrid;\n    }\n    return tileGrid;\n  }\n\n  /**\n   * Get the tile pixel ratio for this source.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n  getTilePixelRatio(pixelRatio) {\n    return pixelRatio;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   */\n  getTilePixelSize(z, pixelRatio, projection) {\n    const tileGrid = this.getTileGridForProjection(projection);\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    return [\n      Math.round(tileSize[0] * pixelRatio),\n      Math.round(tileSize[1] * pixelRatio),\n    ];\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  updateCacheSize(tileCount, projection) {\n    super.updateCacheSize(tileCount * 2, projection);\n    this.sourceTileCache.highWaterMark =\n      this.getTileCacheForProjection(projection).highWaterMark;\n  }\n}\n\nexport default VectorTile;\n\n/**\n * Sets the loader for a tile.\n * @param {import(\"../VectorTile.js\").default} tile Vector tile.\n * @param {string} url URL.\n */\nexport function defaultLoadFunction(tile, url) {\n  tile.setLoader(\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} resolution Resolution.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     */\n    function (extent, resolution, projection) {\n      loadFeaturesXhr(\n        url,\n        tile.getFormat(),\n        extent,\n        resolution,\n        projection,\n        tile.onLoad.bind(tile),\n        tile.onError.bind(tile)\n      );\n    }\n  );\n}\n"]},"metadata":{},"sourceType":"module"}