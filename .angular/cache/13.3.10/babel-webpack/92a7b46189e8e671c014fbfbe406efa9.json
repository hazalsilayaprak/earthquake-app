{"ast":null,"code":"import _asyncToGenerator from \"/Users/hazalsilayaprak/Projects/earthquake-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BaseSource } from './basesource.js';\n\nclass FileReaderSource extends BaseSource {\n  constructor(file) {\n    super();\n    this.file = file;\n  }\n\n  fetchSlice(slice, signal) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      return new Promise((resolve, reject) => {\n        const blob = _this.file.slice(slice.offset, slice.offset + slice.length);\n\n        const reader = new FileReader();\n\n        reader.onload = event => resolve(event.target.result);\n\n        reader.onerror = reject;\n        reader.onabort = reject;\n        reader.readAsArrayBuffer(blob);\n\n        if (signal) {\n          signal.addEventListener('abort', () => reader.abort());\n        }\n      });\n    })();\n  }\n\n}\n/**\n * Create a new source from a given file/blob.\n * @param {Blob} file The file or blob to read from.\n * @returns The constructed source\n */\n\n\nexport function makeFileReaderSource(file) {\n  return new FileReaderSource(file);\n}","map":{"version":3,"sources":["/Users/hazalsilayaprak/Projects/earthquake-app/node_modules/geotiff/dist-module/source/filereader.js"],"names":["BaseSource","FileReaderSource","constructor","file","fetchSlice","slice","signal","Promise","resolve","reject","blob","offset","length","reader","FileReader","onload","event","target","result","onerror","onabort","readAsArrayBuffer","addEventListener","abort","makeFileReaderSource"],"mappings":";AAAA,SAASA,UAAT,QAA2B,iBAA3B;;AAEA,MAAMC,gBAAN,SAA+BD,UAA/B,CAA0C;AACxCE,EAAAA,WAAW,CAACC,IAAD,EAAO;AAChB;AACA,SAAKA,IAAL,GAAYA,IAAZ;AACD;;AAEKC,EAAAA,UAAU,CAACC,KAAD,EAAQC,MAAR,EAAgB;AAAA;;AAAA;AAC9B,aAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,cAAMC,IAAI,GAAG,KAAI,CAACP,IAAL,CAAUE,KAAV,CAAgBA,KAAK,CAACM,MAAtB,EAA8BN,KAAK,CAACM,MAAN,GAAeN,KAAK,CAACO,MAAnD,CAAb;;AACA,cAAMC,MAAM,GAAG,IAAIC,UAAJ,EAAf;;AACAD,QAAAA,MAAM,CAACE,MAAP,GAAiBC,KAAD,IAAWR,OAAO,CAACQ,KAAK,CAACC,MAAN,CAAaC,MAAd,CAAlC;;AACAL,QAAAA,MAAM,CAACM,OAAP,GAAiBV,MAAjB;AACAI,QAAAA,MAAM,CAACO,OAAP,GAAiBX,MAAjB;AACAI,QAAAA,MAAM,CAACQ,iBAAP,CAAyBX,IAAzB;;AAEA,YAAIJ,MAAJ,EAAY;AACVA,UAAAA,MAAM,CAACgB,gBAAP,CAAwB,OAAxB,EAAiC,MAAMT,MAAM,CAACU,KAAP,EAAvC;AACD;AACF,OAXM,CAAP;AAD8B;AAa/B;;AAnBuC;AAsB1C;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAASC,oBAAT,CAA8BrB,IAA9B,EAAoC;AACzC,SAAO,IAAIF,gBAAJ,CAAqBE,IAArB,CAAP;AACD","sourcesContent":["import { BaseSource } from './basesource.js';\n\nclass FileReaderSource extends BaseSource {\n  constructor(file) {\n    super();\n    this.file = file;\n  }\n\n  async fetchSlice(slice, signal) {\n    return new Promise((resolve, reject) => {\n      const blob = this.file.slice(slice.offset, slice.offset + slice.length);\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event.target.result);\n      reader.onerror = reject;\n      reader.onabort = reject;\n      reader.readAsArrayBuffer(blob);\n\n      if (signal) {\n        signal.addEventListener('abort', () => reader.abort());\n      }\n    });\n  }\n}\n\n/**\n * Create a new source from a given file/blob.\n * @param {Blob} file The file or blob to read from.\n * @returns The constructed source\n */\nexport function makeFileReaderSource(file) {\n  return new FileReaderSource(file);\n}\n"]},"metadata":{},"sourceType":"module"}